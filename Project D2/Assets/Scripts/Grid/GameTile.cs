using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using UnityEngine.EventSystems;
using UnityEngine.Assertions;

public class GameTile
{
    /**The X coordinate of this GameTile in its Grid. */
    public int X { get; private set; }

    /**The X world position of this GameTile in its Grid. */
    public float WorldX { get; private set; }

    /**The Y world position of this GameTile in its Grid. */
    public float WorldY { get; private set; }

    /**The Y coordinate of this GameTile in its Grid. */
    public int Y { get; private set; }

    /**The GameObject this tile holds. */
    public GameObject objectHolding;

    /**The GameGrid this Tile is in. */
    public GameGrid GridIn { get; private set; }

    /**True if this tile holds an objectHolding.*/
    public bool TileSetUp { get; private set; }

    /**The SpriteRenderer component of objectHolding.*/
    public SpriteRenderer tileSpriteRenderer;

    /**The next GameTile to pass items to. Assigned manually.*/
    public GameTile NextGameTile { get; private set; }

    /**True if something is on this tile, even if it doesn't have an objectHolding.*/
    public bool Occupied { get; private set; }

    /**Name of the thing occupying this GameTile. */
    public string GameTileName { get; private set; }

    /**Creates an object of type GameTile.
     
     (1) x: the x grid coordinate of this GameTile, > 0 
     (2) y: the y grid coordinate of this GameTile, > 0
     (3) worldX: the transform.position.x of this GameTile's objectHolding, > 0
     (4) worldY: the transform.position.y of this GameTile's objectHolding, > 0   
     (5) grid: the GameGrid that this tile was generated by, not null. */

    public GameTile(int x, int y, float worldX, float worldY, GameGrid grid)
    {
        Assert.IsTrue(x >= 0 && y >= 0, "The grid coordinates of this game tile must be >= 0.");
        Assert.IsTrue(worldX >= 0 && worldY >= 0, "The world coordinates of this game tile must be >= 0");
        Assert.IsNotNull(grid, "The GameGrid of this GameTile cannot be null.");

        X = x;
        WorldX = worldX;

        Y = y;
        WorldY = worldY;

        GridIn = grid;
    }

    /**Fills this tile with a GameObject. 
     (1) prefabSource: a link to a valid prefab
     (2) nextTile: the next tile of the tile being filled
     (3) name: the name of what this tile is being filled with
     (4) size: the x and y width and height, respectively, of the tile being filled
     (5) direction: the direction (NESW) this tile is facing */
    public void FillTile(string prefabSource, GameTile nextTile, string name, Vector2 size, Conveyor.Direction direction)
    {
        if (!TileSetUp) AdaptTile(GameObject.Instantiate(Resources.Load(prefabSource) as GameObject), size, direction);

        NextGameTile = nextTile;

        OccupyTile(name);
    }

    /**Sets Occupied to true and assigns this GameTile a name. */
    public void OccupyTile(string name)
    {
        Occupied = true;
        GameTileName = name;
    }

    /**Removes the GameObject from this tile. */
    public void RemoveTileObject()
    {
        objectHolding = null;
        Occupied = false;
    }

    /**Returns a string representation of this GameTile.
     * "(X,Y)" */
    public override string ToString()
    {
        return "(" + X + ", " + Y + ")";
    }



    /** Creates the Tile in the scene.
      (1) spriteToSet: the Sprite to assign to this created tile's SpriteRenderer. */
    public void CreateRealTile(Sprite spriteToSet)
    {
        GameObject newTile = new GameObject("NewTile");
        objectHolding = newTile;

        Transform newTileTransform = newTile.transform;
        newTileTransform.localPosition = new Vector2(WorldX, WorldY);
        newTileTransform.localScale = new Vector2(GridIn.CellSize +.01f, GridIn.CellSize + .01f);
        newTileTransform.SetParent(GridIn.ParentGameObject);

        newTile.AddComponent<SpriteRenderer>().sprite = spriteToSet;
        tileSpriteRenderer = objectHolding.GetComponent<SpriteRenderer>();
        tileSpriteRenderer.sortingOrder = GridIn.SortingOrder;

        TileSetUp = true;
    }


    /**Modifies an existing GameObject to fit within its assigned tile.
      (1) tileToAdapt: the existing GameObject to modify.
      (2) size: the x and y width and height, respectively, of this tile.
      (3) direction: the direction (NESW) this tile is facing. */
    public void AdaptTile(GameObject tileToAdapt, Vector2 size, Conveyor.Direction direction)
    {
        Debug.Log(direction);

        objectHolding = tileToAdapt;

        Transform tileToAdaptTransform = tileToAdapt.transform;

        Vector2 tilePosition = new Vector2(WorldX + ((size.x * GridIn.CellSize) - GridIn.CellSize)/2, WorldY - ((size.y * GridIn.CellSize) - GridIn.CellSize)/2);
        tileToAdaptTransform.localPosition = tilePosition;

        if (direction == Conveyor.Direction.West) tileToAdaptTransform.Rotate(Vector3.forward * 90);
        else if (direction == Conveyor.Direction.South) tileToAdaptTransform.Rotate(Vector3.forward * 180);
        else if (direction == Conveyor.Direction.East) tileToAdaptTransform.Rotate(Vector3.forward * 270);



        tileToAdaptTransform.localScale = new Vector2(GridIn.CellSize + .01f, GridIn.CellSize + .01f);
        tileToAdaptTransform.SetParent(GridIn.ParentGameObject);
        if (tileToAdapt.GetComponent<Item>() != null) tileToAdapt.GetComponent<Item>().AssignGameTile(this);

        TileSetUp = true;
    }
}
